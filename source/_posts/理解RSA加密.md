---
title: 理解RSA加解密
date: 2017-06-10 17:18:37
tags:
- RSA
- 加密
categories:
- 浏览器
---

# 基本概念

参考阮一峰老师的文章

RSA算法原理（一）介绍了RSA算法用到的数学公式工具：http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html

RSA算法原理（二）以一组demo讲解RSA密钥的生成和不可逆性：http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html

符号说明：

`≡` 同余。两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余，记作a≡b(mod m)，读作a同余于b模m，或读作a与b关于模m同余。

<!-- more -->

我的补充(有助于自己理解的补充)

# 用公钥加密为什么不能用公钥解密？

这一点不同于不可逆加密算法，不可逆加密算法不需要密钥也不能被解密，只有的到对应的明文，重新加密，才能确定明文和密文的对应关系。

非对称加密是可逆的，所以用公钥加密，一定可以用公钥解密。概念上没有问题，可是解密现阶段无法实现或者实现成本太高。

举个简单的例子，我们人力计算`11`的`11`次幂，还是有希望能计算出来的，但是给你一个数 `285311670611` 让你计算这个数字的开`11`次方，人力还可以计算出来么？
这个例子中，幂指数 `11` 作为我们的密钥，求值过程为加密过程，那么这完全是一个可逆的加密，但是对于人力来说，却是“不可逆”。

当然，这里例子中的“不可逆”对于计算机来说就是小菜一碟了，所以我们需要对于计算机也要计算量超级大的解密算法，来让计算机也不能用公钥去解密；
并且我们需要解密过程可以化简变形，在我们知道私钥的情况下，解密过程的计算量极大减少，并且公钥不能推导出私钥。

基于这样的诉求，RSA诞生了。这些数学家真的脑子怎么长的=.=

# RSA加密算法的理解

加密要用公钥 (n,e)

![](/images/201706061114041.png)

解密要用私钥(n,d)

![](/images/201706061114242.png)

用公钥推导私钥

```text
（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。
（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。
（3）n=pq。只有将n因数分解，才能算出p和q。
```

结论：

- 由公式1可以看出，用公钥加密算法加密以后，我们想用算法的逆变换去解密，对于电脑来说也是一项“不可逆”的工作量了。
- 由公式2可以看出，对加密算法进行一系列推导，我们如果知道私钥(d)，即可以很少的工作量去解密密文。
- 公钥推导私钥需要对 `n` 进行因数分解，而大整数的因数分解，是一件非常困难的事情，目前，除了暴力破解，还没有发现别的有效方法。

基于以上三点，RSA完全符合我们对非对称加密的诉求

# 加解密相关

## 加解密速度问题

即使用密钥解密在计算机的计算能力内了，可是依旧需要很大的计算量，而且公钥和私钥的大小相差很大，这就直接导致了加密和解密的计算量差别很大。

当前公钥加密速度大约是12000次/秒，私钥解密速度约是300次/秒。

```text
n=119263477369052012922637196530783652401581445956350841560954863526975117908165699062010236394009208141897875804687843459842125106550108593510740467934411286423507269375591768884321570401534909084090161637144873510938388101883333290501884915534203304006197643606655871549571440181559411792469912124238983204579

e=65537

d=57281481867428326148066756720623114067543207262585340186675866140326773981038676005537272242767106286258440830434094459396227657336737540594436390270709116600548275303062471272502940472389614010092413136147606051219547590060791675176641306271494019790111235852053008032643494254448830003976266489627722404537

# 由这组数据可以看出，公钥中 `e` 作为幂指数和私钥中 `d` 作为幂指数的计算量的差别。
```

![](/images/20170606112944.png)

## 明文、密文长度问题

（1）明文长度

不管明文长度是多少，RSA 生成的密文长度总是固定的。但是明文长度不能超过密钥长度。比如 Java 默认的 RSA 加密实现不允许明文长度超过密钥长度减去 11(单位是字节，也就是 byte)。也就是说，如果我们定义的密钥(我们可以通过 java.security.KeyPairGenerator.initialize(int keysize) 来定义密钥长度)长度为 1024(单位是位，也就是 bit)，生成的密钥长度就是 1024位 / 8位/字节 = 128字节，那么我们需要加密的明文长度不能超过 128字节 - 11 字节 = 117字节。也就是说，我们最大能将 117 字节长度的明文进行加密，否则会出问题(抛诸如 javax.crypto.IllegalBlockSizeException: Data must not be longer than 53 bytes 的异常)。而 BC 提供的加密算法能够支持到的 RSA 明文长度最长为密钥长度。

（2）密文长度

生成密文的长度等于密钥长度。密钥长度越大，生成密文的长度也就越大，加密的速度也就越慢，而密文也就越难被破解掉。